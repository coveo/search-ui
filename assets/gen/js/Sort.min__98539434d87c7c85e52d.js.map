{"version":3,"sources":["Sort.min__98539434d87c7c85e52d.js","./src/ui/Sort/Sort.ts","./src/ui/Sort/SortCriteria.ts"],"names":["webpackJsonpCoveo__temporary","192","module","exports","__webpack_require__","__extends","this","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","value","element","options","bindings","Sort","ID","ComponentOptions","initComponentOptions","Assert","isLargerOrEqualsThan","sortCriteria","length","bind","onQueryState","MODEL_EVENTS","CHANGE_ONE","QUERY_STATE_ATTRIBUTES","SORT","handleQueryStateChanged","onRootElement","QueryEvents","querySuccess","args","handleQuerySuccess","buildingQuery","handleBuildingQuery","queryError","handleQueryError","ensureDom","_this","createDom","el","$$","on","selectAndExecuteQuery","innerText","text","empty","findOrCreateRadioGroup","createSortButton","isToggle","createDirectionButton","update","select","direction","currentCriteria","find","criteria","updateQueryStateModel","Utils","exists","selectNextCriteria","selectFirstCriteria","oldCriteria","executeSearchQuery","enable","removeClass","disable","addClass","getCurrentCriteria","match","sortId","any","toString","radioGroup","findRadioGroup","setAttribute","sortButton","caption","AccessibleButton","withElement","withEnterKeyboardAction","withArrowsAction","e","onArrowPressed","withLabel","getDirectionalLabel","initialDirection","getOmnidirectionalLabel","withRole","build","appendChild","directionButton","className","createIcons","withSelectAction","stopPropagation","selectNextCriteriaAndExecuteQuery","VALID_DIRECTION","DESCENDING","ASCENDING","selectNextRadioButton","ArrowDirection","RIGHT","DOWN","iconAscending","SVGIcons","icons","arrowUp","SVGDom","addClassToSVGInContainer","iconDescending","arrowDown","document","body","getAttribute","parentElement","indexToSelect","radioButtons","findAll","currentIndex","findIndex","radio","radioToSelect","focus","click","queryController","deferExecuteQuery","beforeExecuteQuery","logSortEvent","usageAnalytics","sort","indexOfCurrentCriteria","indexOf","queryStateModel","get","QueryStateModel","attributesEnum","isNonEmptyString","criteriaFromModel","SortCriteria","parse","equals","updateAppearance","updateAccessibilityProperties","enumerable","configurable","captionIsDefined","textContent","data","defaultAttributes","isSelected","putInQueryBuilder","queryBuilder","results","toggleClass","currentDirection","resultListsIds","directionIsInitial","searchInterface","getComponents","map","resultList","id","join","localizedCaption","l","displayedSortText","set","doExport","exportGlobally","buildCustomListOption","values","required","buildLocalizedStringOption","Component","Initialization","registerAutoCreateComponent","498","VALID_SORT","SortCriterion","sortIsField","check","isValidSort","sortNeedsDirection","isValidDirection","chain","contains","charAt","sortsNeedingDirection","DATE","rawCriteriaString","split","forEach","criterion","push","first","574"],"mappings":"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","file":"Sort.min__98539434d87c7c85e52d.js","sourcesContent":["webpackJsonpCoveo__temporary([39],{\n\n/***/ 192:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(574);\nvar GlobalExports_1 = __webpack_require__(3);\nvar QueryEvents_1 = __webpack_require__(11);\nvar Assert_1 = __webpack_require__(5);\nvar Model_1 = __webpack_require__(18);\nvar QueryStateModel_1 = __webpack_require__(13);\nvar Dom_1 = __webpack_require__(1);\nvar SVGDom_1 = __webpack_require__(16);\nvar SVGIcons_1 = __webpack_require__(12);\nvar Utils_1 = __webpack_require__(4);\nvar SharedAnalyticsCalls_1 = __webpack_require__(119);\nvar Component_1 = __webpack_require__(7);\nvar ComponentOptions_1 = __webpack_require__(8);\nvar Initialization_1 = __webpack_require__(2);\nvar SortCriteria_1 = __webpack_require__(498);\nvar AccessibleButton_1 = __webpack_require__(15);\nvar Strings_1 = __webpack_require__(6);\nvar underscore_1 = __webpack_require__(0);\n/**\n * The `Sort` component renders a widget that the end user can interact with to select the criterion to use when sorting query results.\n *\n * To improve accessibility, it's recommended to group `Sort` components in a container with `role=\"radiogroup\"`.\n */\nvar Sort = /** @class */ (function (_super) {\n    __extends(Sort, _super);\n    /**\n     * Creates a new `Sort` component instance.\n     * @param element The HTMLElement on which to instantiate the component.\n     * @param options The options for this component instance.\n     * @param bindings The bindings that the component requires to function normally. If not set, these will be\n     * automatically resolved (with a slower execution time).\n     */\n    function Sort(element, options, bindings) {\n        var _this = _super.call(this, element, Sort.ID, bindings) || this;\n        _this.element = element;\n        _this.options = options;\n        _this.options = ComponentOptions_1.ComponentOptions.initComponentOptions(element, Sort, options);\n        Assert_1.Assert.isLargerOrEqualsThan(1, _this.options.sortCriteria.length);\n        _this.bind.onQueryState(Model_1.MODEL_EVENTS.CHANGE_ONE, QueryStateModel_1.QUERY_STATE_ATTRIBUTES.SORT, function () { return _this.handleQueryStateChanged(); });\n        _this.bind.onRootElement(QueryEvents_1.QueryEvents.querySuccess, function (args) { return _this.handleQuerySuccess(args); });\n        _this.bind.onRootElement(QueryEvents_1.QueryEvents.buildingQuery, function (args) { return _this.handleBuildingQuery(args); });\n        _this.bind.onRootElement(QueryEvents_1.QueryEvents.queryError, function (args) { return _this.handleQueryError(args); });\n        _this.ensureDom();\n        return _this;\n    }\n    Sort.prototype.createDom = function () {\n        var _this = this;\n        var el = Dom_1.$$(this.element);\n        el.on('click', function () { return _this.selectAndExecuteQuery(); });\n        var innerText = el.text();\n        el.empty();\n        this.findOrCreateRadioGroup();\n        this.createSortButton(innerText);\n        if (this.isToggle()) {\n            this.createDirectionButton();\n        }\n        this.update();\n    };\n    /**\n     * Selects this `Sort` component.\n     *\n     * Updates the state model if selecting this component toggles its current [`sortCriteria`]{@link Sort.options.sortCriteria}.\n     *\n     * @param direction The sort direction. Can be one of: `ascending`, `descending`.\n     */\n    Sort.prototype.select = function (direction) {\n        if (direction) {\n            this.currentCriteria = underscore_1.find(this.options.sortCriteria, function (criteria) {\n                return criteria.direction == direction;\n            });\n            this.updateQueryStateModel();\n        }\n        else if (Utils_1.Utils.exists(this.currentCriteria)) {\n            this.selectNextCriteria();\n        }\n        else {\n            this.selectFirstCriteria();\n        }\n    };\n    /**\n     * Selects this `Sort` component, then triggers a query if selecting this component toggles its current [`sortCriteria`]{@link Sort.options.sortCriteria}.\n     *\n     * Also logs an event in the usage analytics with the new current sort criteria.\n     */\n    Sort.prototype.selectAndExecuteQuery = function () {\n        var oldCriteria = this.currentCriteria;\n        this.select();\n        if (oldCriteria != this.currentCriteria) {\n            this.executeSearchQuery();\n        }\n    };\n    Sort.prototype.enable = function () {\n        Dom_1.$$(this.element).removeClass('coveo-tab-disabled');\n        this.update();\n        _super.prototype.enable.call(this);\n    };\n    Sort.prototype.disable = function () {\n        Dom_1.$$(this.element).addClass('coveo-tab-disabled');\n        _super.prototype.disable.call(this);\n    };\n    /**\n     * Gets the current [`sortCriteria`]{@link Sort.options.sortCriteria} of this `Sort` component.\n     * @returns {SortCriteria}\n     */\n    Sort.prototype.getCurrentCriteria = function () {\n        return this.currentCriteria;\n    };\n    /**\n     * Indicates whether the name of any of the available [`sortCriteria`]{@link Sort.options.sortCriteria} of this `Sort` component matches the argument.\n     * @param sortId The sort criteria name to look for (e.g., `date descending`).\n     */\n    Sort.prototype.match = function (sortId) {\n        return underscore_1.any(this.options.sortCriteria, function (sortCriteria) { return sortId == sortCriteria.toString(); });\n    };\n    Sort.prototype.findOrCreateRadioGroup = function () {\n        this.radioGroup = this.findRadioGroup();\n        if (!this.radioGroup) {\n            this.element.setAttribute('role', 'radiogroup');\n            this.radioGroup = this.element;\n        }\n    };\n    Sort.prototype.createSortButton = function (innerText) {\n        var _this = this;\n        this.sortButton = Dom_1.$$('span').el;\n        this.sortButton.innerText = this.options.caption || innerText;\n        new AccessibleButton_1.AccessibleButton()\n            .withElement(this.sortButton)\n            .withEnterKeyboardAction(function () { return _this.selectAndExecuteQuery(); })\n            .withArrowsAction(function (direction, e) { return _this.onArrowPressed(direction, e); })\n            .withLabel(this.isToggle() ? this.getDirectionalLabel(this.initialDirection) : this.getOmnidirectionalLabel())\n            .withRole('radio')\n            .build();\n        this.element.appendChild(this.sortButton);\n    };\n    Sort.prototype.createDirectionButton = function () {\n        var _this = this;\n        this.directionButton = Dom_1.$$.apply(void 0, ['span', { className: 'coveo-icon' }].concat(this.createIcons())).el;\n        new AccessibleButton_1.AccessibleButton()\n            .withElement(this.directionButton)\n            .withSelectAction(function (e) {\n            e.stopPropagation();\n            _this.selectNextCriteriaAndExecuteQuery();\n        })\n            .withArrowsAction(function (direction, e) { return _this.onArrowPressed(direction, e); })\n            .withLabel(this.getDirectionalLabel(this.initialDirection === SortCriteria_1.VALID_DIRECTION.DESCENDING ? SortCriteria_1.VALID_DIRECTION.ASCENDING : SortCriteria_1.VALID_DIRECTION.DESCENDING))\n            .withRole('radio')\n            .build();\n        this.element.appendChild(this.directionButton);\n    };\n    Sort.prototype.onArrowPressed = function (direction, e) {\n        this.selectNextRadioButton(direction === AccessibleButton_1.ArrowDirection.RIGHT || direction === AccessibleButton_1.ArrowDirection.DOWN ? 1 : -1);\n        e.stopPropagation();\n    };\n    Sort.prototype.createIcons = function () {\n        var iconAscending = Dom_1.$$('span', { className: 'coveo-sort-icon-ascending' }, SVGIcons_1.SVGIcons.icons.arrowUp);\n        SVGDom_1.SVGDom.addClassToSVGInContainer(iconAscending.el, 'coveo-sort-icon-ascending-svg');\n        var iconDescending = Dom_1.$$('span', { className: 'coveo-sort-icon-descending' }, SVGIcons_1.SVGIcons.icons.arrowDown);\n        SVGDom_1.SVGDom.addClassToSVGInContainer(iconDescending.el, 'coveo-sort-icon-descending-svg');\n        return [iconAscending, iconDescending];\n    };\n    Sort.prototype.findRadioGroup = function (element) {\n        if (element === void 0) { element = this.element; }\n        if (!element || element === document.body) {\n            return null;\n        }\n        if (element.getAttribute('role') === 'radiogroup') {\n            return element;\n        }\n        return this.findRadioGroup(element.parentElement);\n    };\n    Sort.prototype.selectNextRadioButton = function (direction) {\n        if (direction === void 0) { direction = 1; }\n        var radioButtons = Dom_1.$$(this.radioGroup).findAll('[role=\"radio\"]');\n        var currentIndex = underscore_1.findIndex(radioButtons, function (radio) { return radio.getAttribute('aria-checked') === 'true'; });\n        var indexToSelect;\n        var isAnythingSelected = currentIndex !== -1;\n        if (isAnythingSelected) {\n            indexToSelect = (currentIndex + direction + radioButtons.length) % radioButtons.length;\n        }\n        else {\n            if (direction >= 0) {\n                indexToSelect = 0;\n            }\n            else {\n                indexToSelect = radioButtons.length - 1;\n            }\n        }\n        var radioToSelect = radioButtons[indexToSelect];\n        radioToSelect.focus();\n        radioToSelect.click();\n    };\n    Sort.prototype.executeSearchQuery = function () {\n        var _this = this;\n        this.queryController.deferExecuteQuery({\n            beforeExecuteQuery: function () { return SharedAnalyticsCalls_1.logSortEvent(_this.usageAnalytics, _this.currentCriteria.sort + _this.currentCriteria.direction); }\n        });\n    };\n    Sort.prototype.selectFirstCriteria = function () {\n        this.currentCriteria = this.options.sortCriteria[0];\n        this.updateQueryStateModel();\n    };\n    Sort.prototype.selectNextCriteria = function () {\n        var indexOfCurrentCriteria = this.currentCriteria ? this.options.sortCriteria.indexOf(this.currentCriteria) : 0;\n        this.currentCriteria = this.options.sortCriteria[(indexOfCurrentCriteria + 1) % this.options.sortCriteria.length];\n        this.updateQueryStateModel();\n    };\n    Sort.prototype.selectNextCriteriaAndExecuteQuery = function () {\n        var oldCriteria = this.currentCriteria;\n        this.selectNextCriteria();\n        if (oldCriteria != this.currentCriteria) {\n            this.executeSearchQuery();\n        }\n    };\n    Sort.prototype.handleQueryStateChanged = function () {\n        this.update();\n    };\n    Sort.prototype.update = function () {\n        // Basically, if the criteria in the model fits with one of ours, it'll become our active criteria\n        var sortCriteria = this.queryStateModel.get(QueryStateModel_1.QueryStateModel.attributesEnum.sort);\n        if (Utils_1.Utils.isNonEmptyString(sortCriteria)) {\n            var criteriaFromModel = SortCriteria_1.SortCriteria.parse(sortCriteria);\n            this.currentCriteria = underscore_1.find(this.options.sortCriteria, function (criteria) { return criteriaFromModel.equals(criteria); });\n        }\n        else {\n            this.currentCriteria = null;\n        }\n        this.updateAppearance();\n        this.updateAccessibilityProperties();\n    };\n    Object.defineProperty(Sort.prototype, \"captionIsDefined\", {\n        get: function () {\n            return Utils_1.Utils.isNonEmptyString(this.options.caption);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Sort.prototype, \"currentDirection\", {\n        get: function () {\n            return this.currentCriteria ? this.currentCriteria.direction : this.initialDirection;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Sort.prototype, \"initialDirection\", {\n        get: function () {\n            return this.options.sortCriteria[0].direction;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Sort.prototype, \"displayedSortText\", {\n        get: function () {\n            return this.captionIsDefined ? this.options.caption : this.element.textContent;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Sort.prototype.handleBuildingQuery = function (data) {\n        Assert_1.Assert.exists(data);\n        var sort = this.queryStateModel.get(QueryStateModel_1.QueryStateModel.attributesEnum.sort);\n        if (sort == QueryStateModel_1.QueryStateModel.defaultAttributes.sort || this.isSelected()) {\n            if (this.currentCriteria) {\n                this.currentCriteria.putInQueryBuilder(data.queryBuilder);\n            }\n        }\n    };\n    Sort.prototype.handleQuerySuccess = function (data) {\n        if (data.results.results.length == 0) {\n            Dom_1.$$(this.element).addClass('coveo-sort-hidden');\n        }\n        else {\n            Dom_1.$$(this.element).removeClass('coveo-sort-hidden');\n        }\n    };\n    Sort.prototype.handleQueryError = function (data) {\n        Dom_1.$$(this.element).addClass('coveo-sort-hidden');\n    };\n    Sort.prototype.isToggle = function () {\n        return this.options.sortCriteria.length > 1;\n    };\n    Sort.prototype.isSelected = function () {\n        return Utils_1.Utils.exists(this.currentCriteria);\n    };\n    Sort.prototype.updateAppearance = function () {\n        Dom_1.$$(this.element).toggleClass('coveo-selected', this.isSelected());\n        if (this.isToggle()) {\n            Dom_1.$$(this.element).removeClass('coveo-ascending');\n            Dom_1.$$(this.element).removeClass('coveo-descending');\n            if (this.isSelected()) {\n                Dom_1.$$(this.element).addClass(this.currentDirection === 'ascending' ? 'coveo-ascending' : 'coveo-descending');\n            }\n        }\n    };\n    Sort.prototype.updateAccessibilityProperties = function () {\n        this.sortButton.setAttribute('aria-controls', this.resultListsIds);\n        var directionIsInitial = this.currentDirection === this.initialDirection;\n        this.sortButton.setAttribute('aria-checked', \"\" + (this.isSelected() && directionIsInitial));\n        if (this.isToggle()) {\n            this.directionButton.setAttribute('aria-controls', this.resultListsIds);\n            this.directionButton.setAttribute('aria-checked', \"\" + (this.isSelected() && !directionIsInitial));\n        }\n    };\n    Object.defineProperty(Sort.prototype, \"resultListsIds\", {\n        get: function () {\n            var resultLists = this.searchInterface.getComponents('ResultList');\n            return resultLists.map(function (resultList) { return resultList.element.id; }).join(' ');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Sort.prototype.getDirectionalLabel = function (direction) {\n        var localizedCaption = Strings_1.l(this.displayedSortText);\n        return direction === SortCriteria_1.VALID_DIRECTION.DESCENDING\n            ? Strings_1.l('SortResultsByDescending', localizedCaption)\n            : Strings_1.l('SortResultsByAscending', localizedCaption);\n    };\n    Sort.prototype.getOmnidirectionalLabel = function () {\n        var localizedCaption = Strings_1.l(this.displayedSortText);\n        return Strings_1.l('SortResultsBy', localizedCaption);\n    };\n    Sort.prototype.updateQueryStateModel = function () {\n        this.queryStateModel.set(QueryStateModel_1.QueryStateModel.attributesEnum.sort, this.currentCriteria.toString());\n    };\n    Sort.ID = 'Sort';\n    Sort.doExport = function () {\n        GlobalExports_1.exportGlobally({\n            Sort: Sort,\n            SortCriteria: SortCriteria_1.SortCriteria\n        });\n    };\n    /**\n     * Options for the component\n     * @componentOptions\n     */\n    Sort.options = {\n        /**\n         * The sort criterion/criteria the end user can select/toggle between when interacting with this component instance.\n         *\n         * The available sort criteria are:\n         * - `relevancy`\n         * - `date ascending`/`date descending`\n         * - `qre`\n         * - `@field ascending`/`@field descending`, where you must replace `field` with the name of a sortable field in your index (e.g., `data-sort-criteria=\"@size ascending\"`).\n         *\n         * You can specify a comma separated list of sort criteria to toggle between when interacting with this component instance (e.g., `data-sort-criteria=\"date descending,date ascending\"`).\n         *\n         * You can specify multiple sort criteria to be used in the same request by separating them with a semicolon (e.g., `data-sort-criteria=\"@size ascending;date ascending\"` ).\n         *\n         * Interacting with this component instance will cycle through those criteria in the order they are listed in.\n         * Typically, you should only specify a list of sort criteria when you want the end user to be able to to toggle the direction of a `date` or `@field` sort criteria.\n         * Otherwise, you should configure a distinct `Sort` component instance for each sort criterion you want to make available in your search page.\n         *\n         * You must specify a valid value for this option in order for this component instance to work correctly.\n         *\n         * Examples:\n         *\n         * - `data-sort-criteria=\"date ascending\"` createes a Sort component that allows to sort on `date ascending`, without being able to toggle the order.\n         * - `data-sort-criteria=\"date ascending, date descending\"` creates a Sort component that allows end users to toggle between `date ascending` and `date descending` on click.\n         * - `data-sort-criteria=\"@size ascending; date descending\"` creates a Sort component that only allows end users to sort on `@size ascending`. The index then applies a second sort on `date descending` when two items are of equal value.\n         * - `data-sort-criteria=\"@size ascending; date descending, @size descending; date descending\"` creates a Sort component that allows end users to toggle between `@size ascending` and `@size descending`. For each value, the index applies a second sort on `date descending` when two items are of equal value.\n         */\n        sortCriteria: ComponentOptions_1.ComponentOptions.buildCustomListOption(function (values) {\n            return values.map(function (criteria) {\n                // 'any' because Underscore won't accept the union type as an argument.\n                if (typeof criteria === 'string') {\n                    return new SortCriteria_1.SortCriteria(criteria);\n                }\n                else {\n                    return criteria;\n                }\n            });\n        }, { required: true }),\n        /**\n         * The caption to display on this component instance.\n         *\n         * By default, the component uses the text content of the element it is instanciated on.\n         */\n        caption: ComponentOptions_1.ComponentOptions.buildLocalizedStringOption({ required: true })\n    };\n    return Sort;\n}(Component_1.Component));\nexports.Sort = Sort;\nInitialization_1.Initialization.registerAutoCreateComponent(Sort);\n\n\n/***/ }),\n\n/***/ 498:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar underscore_1 = __webpack_require__(0);\nvar Assert_1 = __webpack_require__(5);\nvar VALID_SORT;\n(function (VALID_SORT) {\n    VALID_SORT[\"RELEVANCY\"] = \"relevancy\";\n    VALID_SORT[\"DATE\"] = \"date\";\n    VALID_SORT[\"QRE\"] = \"qre\";\n})(VALID_SORT = exports.VALID_SORT || (exports.VALID_SORT = {}));\nvar VALID_DIRECTION;\n(function (VALID_DIRECTION) {\n    VALID_DIRECTION[\"ASCENDING\"] = \"ascending\";\n    VALID_DIRECTION[\"DESCENDING\"] = \"descending\";\n})(VALID_DIRECTION = exports.VALID_DIRECTION || (exports.VALID_DIRECTION = {}));\nvar SortCriterion = /** @class */ (function () {\n    /**\n     * Create a new SortCriteria\n     * @param sort The sort criteria (e.g.: relevancy, date)\n     * @param direction The direction by which to sort (e.g.: ascending, descending)\n     */\n    function SortCriterion(sort, direction) {\n        if (direction === void 0) { direction = ''; }\n        this.sort = sort;\n        this.direction = direction;\n        if (!SortCriterion.sortIsField(sort)) {\n            Assert_1.Assert.check(this.isValidSort(sort), sort + \" is not a valid sort criteria. Valid values are \" + underscore_1.values(VALID_SORT) + \" or a valid index sortable index field.\");\n        }\n        if (SortCriterion.sortNeedsDirection(sort)) {\n            Assert_1.Assert.check(this.isValidDirection(direction), direction + \" is not a valid sort criteria direction. Valid values are \" + underscore_1.values(VALID_DIRECTION));\n        }\n        else {\n            Assert_1.Assert.check(direction == '');\n        }\n    }\n    SortCriterion.prototype.isValidDirection = function (direction) {\n        return underscore_1.chain(VALID_DIRECTION)\n            .values()\n            .contains(direction)\n            .value();\n    };\n    SortCriterion.prototype.isValidSort = function (sort) {\n        return underscore_1.chain(VALID_SORT)\n            .values()\n            .contains(sort)\n            .value();\n    };\n    SortCriterion.sortIsField = function (criteria) {\n        return criteria.charAt(0) == '@';\n    };\n    SortCriterion.sortNeedsDirection = function (sort) {\n        return underscore_1.contains(SortCriterion.sortsNeedingDirection, sort) || SortCriterion.sortIsField(sort);\n    };\n    SortCriterion.sortsNeedingDirection = [VALID_SORT.DATE];\n    return SortCriterion;\n}());\nexports.SortCriterion = SortCriterion;\nvar SortCriteria = /** @class */ (function () {\n    function SortCriteria(rawCriteriaString) {\n        var _this = this;\n        this.criteria = [];\n        var criteria = rawCriteriaString.split(';');\n        criteria.forEach(function (criterion) {\n            var split = criterion.match(/\\S+/g);\n            _this.criteria.push(new SortCriterion(split[0], split[1]));\n        });\n    }\n    Object.defineProperty(SortCriteria.prototype, \"direction\", {\n        get: function () {\n            return underscore_1.first(this.criteria).direction;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SortCriteria.prototype, \"sort\", {\n        get: function () {\n            return underscore_1.first(this.criteria).sort;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Return a new SortCriteria from a string\n     * @param criteria The string from which to create the SortCriteria\n     */\n    SortCriteria.parse = function (criteria) {\n        return new SortCriteria(criteria);\n    };\n    /**\n     * Put the sort criteria in the passed queryBuilder\n     * @param queryBuilder The queryBuilder in which to put the sort criteria.\n     */\n    SortCriteria.prototype.putInQueryBuilder = function (queryBuilder) {\n        Assert_1.Assert.exists(queryBuilder);\n        queryBuilder.sortCriteria = this.toString()\n            .split(';')\n            .join(',');\n    };\n    /**\n     * Returns a string representation of the sort criteria (e.g.: 'date ascending').\n     */\n    SortCriteria.prototype.toString = function () {\n        return this.criteria\n            .map(function (criterion) {\n            return criterion.direction ? criterion.sort + \" \" + criterion.direction : \"\" + criterion.sort;\n        })\n            .join(';');\n    };\n    /**\n     * Checks if the SortCriteria is equal to another.\n     * @param criteria The SortCriteria to compare with\n     */\n    SortCriteria.prototype.equals = function (criteria) {\n        return criteria.toString() == this.toString();\n    };\n    return SortCriteria;\n}());\nexports.SortCriteria = SortCriteria;\n\n\n/***/ }),\n\n/***/ 574:\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// Sort.min__98539434d87c7c85e52d.js","import 'styling/_Sort';\nimport { exportGlobally } from '../../GlobalExports';\nimport { IBuildingQueryEventArgs, IQueryErrorEventArgs, IQuerySuccessEventArgs, QueryEvents } from '../../events/QueryEvents';\nimport { Assert } from '../../misc/Assert';\nimport { MODEL_EVENTS } from '../../models/Model';\nimport { QUERY_STATE_ATTRIBUTES, QueryStateModel } from '../../models/QueryStateModel';\nimport { $$ } from '../../utils/Dom';\nimport { SVGDom } from '../../utils/SVGDom';\nimport { SVGIcons } from '../../utils/SVGIcons';\nimport { Utils } from '../../utils/Utils';\nimport { logSortEvent } from '../Analytics/SharedAnalyticsCalls';\nimport { Component } from '../Base/Component';\nimport { IComponentBindings } from '../Base/ComponentBindings';\nimport { ComponentOptions } from '../Base/ComponentOptions';\nimport { Initialization } from '../Base/Initialization';\nimport { SortCriteria, VALID_DIRECTION } from './SortCriteria';\nimport { AccessibleButton, ArrowDirection } from '../../utils/AccessibleButton';\nimport { l } from '../../strings/Strings';\nimport { findIndex, find, any } from 'underscore';\n\nexport interface ISortOptions {\n  sortCriteria?: SortCriteria[];\n  caption?: string;\n}\n/**\n * The `Sort` component renders a widget that the end user can interact with to select the criterion to use when sorting query results.\n *\n * To improve accessibility, it's recommended to group `Sort` components in a container with `role=\"radiogroup\"`.\n */\nexport class Sort extends Component {\n  static ID = 'Sort';\n\n  static doExport = () => {\n    exportGlobally({\n      Sort: Sort,\n      SortCriteria: SortCriteria\n    });\n  };\n\n  /**\n   * Options for the component\n   * @componentOptions\n   */\n  static options: ISortOptions = {\n    /**\n     * The sort criterion/criteria the end user can select/toggle between when interacting with this component instance.\n     *\n     * The available sort criteria are:\n     * - `relevancy`\n     * - `date ascending`/`date descending`\n     * - `qre`\n     * - `@field ascending`/`@field descending`, where you must replace `field` with the name of a sortable field in your index (e.g., `data-sort-criteria=\"@size ascending\"`).\n     *\n     * You can specify a comma separated list of sort criteria to toggle between when interacting with this component instance (e.g., `data-sort-criteria=\"date descending,date ascending\"`).\n     *\n     * You can specify multiple sort criteria to be used in the same request by separating them with a semicolon (e.g., `data-sort-criteria=\"@size ascending;date ascending\"` ).\n     *\n     * Interacting with this component instance will cycle through those criteria in the order they are listed in.\n     * Typically, you should only specify a list of sort criteria when you want the end user to be able to to toggle the direction of a `date` or `@field` sort criteria.\n     * Otherwise, you should configure a distinct `Sort` component instance for each sort criterion you want to make available in your search page.\n     *\n     * You must specify a valid value for this option in order for this component instance to work correctly.\n     *\n     * Examples:\n     *\n     * - `data-sort-criteria=\"date ascending\"` createes a Sort component that allows to sort on `date ascending`, without being able to toggle the order.\n     * - `data-sort-criteria=\"date ascending, date descending\"` creates a Sort component that allows end users to toggle between `date ascending` and `date descending` on click.\n     * - `data-sort-criteria=\"@size ascending; date descending\"` creates a Sort component that only allows end users to sort on `@size ascending`. The index then applies a second sort on `date descending` when two items are of equal value.\n     * - `data-sort-criteria=\"@size ascending; date descending, @size descending; date descending\"` creates a Sort component that allows end users to toggle between `@size ascending` and `@size descending`. For each value, the index applies a second sort on `date descending` when two items are of equal value.\n     */\n    sortCriteria: ComponentOptions.buildCustomListOption(\n      values => {\n        return values.map(criteria => {\n          // 'any' because Underscore won't accept the union type as an argument.\n          if (typeof criteria === 'string') {\n            return new SortCriteria(criteria);\n          } else {\n            return criteria as SortCriteria;\n          }\n        });\n      },\n      { required: true }\n    ),\n\n    /**\n     * The caption to display on this component instance.\n     *\n     * By default, the component uses the text content of the element it is instanciated on.\n     */\n    caption: ComponentOptions.buildLocalizedStringOption({ required: true })\n  };\n\n  private currentCriteria: SortCriteria;\n\n  private sortButton: HTMLElement;\n  private directionButton: HTMLElement;\n  private radioGroup: HTMLElement;\n\n  /**\n   * Creates a new `Sort` component instance.\n   * @param element The HTMLElement on which to instantiate the component.\n   * @param options The options for this component instance.\n   * @param bindings The bindings that the component requires to function normally. If not set, these will be\n   * automatically resolved (with a slower execution time).\n   */\n  constructor(public element: HTMLElement, public options?: ISortOptions, bindings?: IComponentBindings) {\n    super(element, Sort.ID, bindings);\n\n    this.options = ComponentOptions.initComponentOptions(element, Sort, options);\n\n    Assert.isLargerOrEqualsThan(1, this.options.sortCriteria.length);\n\n    this.bind.onQueryState(MODEL_EVENTS.CHANGE_ONE, QUERY_STATE_ATTRIBUTES.SORT, () => this.handleQueryStateChanged());\n    this.bind.onRootElement(QueryEvents.querySuccess, (args: IQuerySuccessEventArgs) => this.handleQuerySuccess(args));\n    this.bind.onRootElement(QueryEvents.buildingQuery, (args: IBuildingQueryEventArgs) => this.handleBuildingQuery(args));\n    this.bind.onRootElement(QueryEvents.queryError, (args: IQueryErrorEventArgs) => this.handleQueryError(args));\n    this.ensureDom();\n  }\n\n  public createDom() {\n    const el = $$(this.element);\n    el.on('click', () => this.selectAndExecuteQuery());\n    const innerText = el.text();\n    el.empty();\n\n    this.findOrCreateRadioGroup();\n    this.createSortButton(innerText);\n    if (this.isToggle()) {\n      this.createDirectionButton();\n    }\n\n    this.update();\n  }\n\n  /**\n   * Selects this `Sort` component.\n   *\n   * Updates the state model if selecting this component toggles its current [`sortCriteria`]{@link Sort.options.sortCriteria}.\n   *\n   * @param direction The sort direction. Can be one of: `ascending`, `descending`.\n   */\n  public select(direction?: string) {\n    if (direction) {\n      this.currentCriteria = find(this.options.sortCriteria, (criteria: SortCriteria) => {\n        return criteria.direction == direction;\n      });\n      this.updateQueryStateModel();\n    } else if (Utils.exists(this.currentCriteria)) {\n      this.selectNextCriteria();\n    } else {\n      this.selectFirstCriteria();\n    }\n  }\n\n  /**\n   * Selects this `Sort` component, then triggers a query if selecting this component toggles its current [`sortCriteria`]{@link Sort.options.sortCriteria}.\n   *\n   * Also logs an event in the usage analytics with the new current sort criteria.\n   */\n\n  public selectAndExecuteQuery() {\n    var oldCriteria = this.currentCriteria;\n    this.select();\n    if (oldCriteria != this.currentCriteria) {\n      this.executeSearchQuery();\n    }\n  }\n\n  public enable() {\n    $$(this.element).removeClass('coveo-tab-disabled');\n    this.update();\n    super.enable();\n  }\n\n  public disable() {\n    $$(this.element).addClass('coveo-tab-disabled');\n    super.disable();\n  }\n\n  /**\n   * Gets the current [`sortCriteria`]{@link Sort.options.sortCriteria} of this `Sort` component.\n   * @returns {SortCriteria}\n   */\n  public getCurrentCriteria(): SortCriteria {\n    return this.currentCriteria;\n  }\n\n  /**\n   * Indicates whether the name of any of the available [`sortCriteria`]{@link Sort.options.sortCriteria} of this `Sort` component matches the argument.\n   * @param sortId The sort criteria name to look for (e.g., `date descending`).\n   */\n  public match(sortId: string) {\n    return any(this.options.sortCriteria, (sortCriteria: SortCriteria) => sortId == sortCriteria.toString());\n  }\n\n  private findOrCreateRadioGroup() {\n    this.radioGroup = this.findRadioGroup();\n    if (!this.radioGroup) {\n      this.element.setAttribute('role', 'radiogroup');\n      this.radioGroup = this.element;\n    }\n  }\n\n  private createSortButton(innerText?: string) {\n    this.sortButton = $$('span').el;\n    this.sortButton.innerText = this.options.caption || innerText;\n    new AccessibleButton()\n      .withElement(this.sortButton)\n      .withEnterKeyboardAction(() => this.selectAndExecuteQuery())\n      .withArrowsAction((direction, e) => this.onArrowPressed(direction, e))\n      .withLabel(this.isToggle() ? this.getDirectionalLabel(this.initialDirection as VALID_DIRECTION) : this.getOmnidirectionalLabel())\n      .withRole('radio')\n      .build();\n    this.element.appendChild(this.sortButton);\n  }\n\n  private createDirectionButton() {\n    this.directionButton = $$('span', { className: 'coveo-icon' }, ...this.createIcons()).el;\n    new AccessibleButton()\n      .withElement(this.directionButton)\n      .withSelectAction(e => {\n        e.stopPropagation();\n        this.selectNextCriteriaAndExecuteQuery();\n      })\n      .withArrowsAction((direction, e) => this.onArrowPressed(direction, e))\n      .withLabel(\n        this.getDirectionalLabel(\n          this.initialDirection === VALID_DIRECTION.DESCENDING ? VALID_DIRECTION.ASCENDING : VALID_DIRECTION.DESCENDING\n        )\n      )\n      .withRole('radio')\n      .build();\n    this.element.appendChild(this.directionButton);\n  }\n\n  private onArrowPressed(direction: ArrowDirection, e: Event) {\n    this.selectNextRadioButton(direction === ArrowDirection.RIGHT || direction === ArrowDirection.DOWN ? 1 : -1);\n    e.stopPropagation();\n  }\n\n  private createIcons() {\n    const iconAscending = $$('span', { className: 'coveo-sort-icon-ascending' }, SVGIcons.icons.arrowUp);\n    SVGDom.addClassToSVGInContainer(iconAscending.el, 'coveo-sort-icon-ascending-svg');\n    const iconDescending = $$('span', { className: 'coveo-sort-icon-descending' }, SVGIcons.icons.arrowDown);\n    SVGDom.addClassToSVGInContainer(iconDescending.el, 'coveo-sort-icon-descending-svg');\n    return [iconAscending, iconDescending];\n  }\n\n  private findRadioGroup(element = this.element) {\n    if (!element || element === document.body) {\n      return null;\n    }\n    if (element.getAttribute('role') === 'radiogroup') {\n      return element;\n    }\n    return this.findRadioGroup(element.parentElement);\n  }\n\n  private selectNextRadioButton(direction = 1) {\n    const radioButtons = $$(this.radioGroup).findAll('[role=\"radio\"]');\n    const currentIndex = findIndex(radioButtons, radio => radio.getAttribute('aria-checked') === 'true');\n    let indexToSelect: number;\n    const isAnythingSelected = currentIndex !== -1;\n    if (isAnythingSelected) {\n      indexToSelect = (currentIndex + direction + radioButtons.length) % radioButtons.length;\n    } else {\n      if (direction >= 0) {\n        indexToSelect = 0;\n      } else {\n        indexToSelect = radioButtons.length - 1;\n      }\n    }\n    const radioToSelect = radioButtons[indexToSelect];\n    radioToSelect.focus();\n    radioToSelect.click();\n  }\n\n  private executeSearchQuery() {\n    this.queryController.deferExecuteQuery({\n      beforeExecuteQuery: () => logSortEvent(this.usageAnalytics, this.currentCriteria.sort + this.currentCriteria.direction)\n    });\n  }\n\n  private selectFirstCriteria() {\n    this.currentCriteria = this.options.sortCriteria[0];\n    this.updateQueryStateModel();\n  }\n\n  private selectNextCriteria() {\n    const indexOfCurrentCriteria = this.currentCriteria ? this.options.sortCriteria.indexOf(this.currentCriteria) : 0;\n    this.currentCriteria = this.options.sortCriteria[(indexOfCurrentCriteria + 1) % this.options.sortCriteria.length];\n    this.updateQueryStateModel();\n  }\n\n  private selectNextCriteriaAndExecuteQuery() {\n    const oldCriteria = this.currentCriteria;\n    this.selectNextCriteria();\n    if (oldCriteria != this.currentCriteria) {\n      this.executeSearchQuery();\n    }\n  }\n\n  private handleQueryStateChanged() {\n    this.update();\n  }\n\n  private update() {\n    // Basically, if the criteria in the model fits with one of ours, it'll become our active criteria\n    var sortCriteria = <string>this.queryStateModel.get(QueryStateModel.attributesEnum.sort);\n    if (Utils.isNonEmptyString(sortCriteria)) {\n      var criteriaFromModel = SortCriteria.parse(sortCriteria);\n      this.currentCriteria = find(this.options.sortCriteria, (criteria: SortCriteria) => criteriaFromModel.equals(criteria));\n    } else {\n      this.currentCriteria = null;\n    }\n    this.updateAppearance();\n    this.updateAccessibilityProperties();\n  }\n\n  private get captionIsDefined() {\n    return Utils.isNonEmptyString(this.options.caption);\n  }\n\n  private get currentDirection() {\n    return this.currentCriteria ? this.currentCriteria.direction : this.initialDirection;\n  }\n\n  private get initialDirection() {\n    return this.options.sortCriteria[0].direction;\n  }\n\n  private get displayedSortText() {\n    return this.captionIsDefined ? this.options.caption : this.element.textContent;\n  }\n\n  private handleBuildingQuery(data: IBuildingQueryEventArgs) {\n    Assert.exists(data);\n\n    var sort = this.queryStateModel.get(QueryStateModel.attributesEnum.sort);\n    if (sort == QueryStateModel.defaultAttributes.sort || this.isSelected()) {\n      if (this.currentCriteria) {\n        this.currentCriteria.putInQueryBuilder(data.queryBuilder);\n      }\n    }\n  }\n\n  private handleQuerySuccess(data: IQuerySuccessEventArgs) {\n    if (data.results.results.length == 0) {\n      $$(this.element).addClass('coveo-sort-hidden');\n    } else {\n      $$(this.element).removeClass('coveo-sort-hidden');\n    }\n  }\n\n  private handleQueryError(data: IQueryErrorEventArgs) {\n    $$(this.element).addClass('coveo-sort-hidden');\n  }\n\n  private isToggle(): boolean {\n    return this.options.sortCriteria.length > 1;\n  }\n\n  private isSelected(): boolean {\n    return Utils.exists(this.currentCriteria);\n  }\n\n  private updateAppearance() {\n    $$(this.element).toggleClass('coveo-selected', this.isSelected());\n    if (this.isToggle()) {\n      $$(this.element).removeClass('coveo-ascending');\n      $$(this.element).removeClass('coveo-descending');\n      if (this.isSelected()) {\n        $$(this.element).addClass(this.currentDirection === 'ascending' ? 'coveo-ascending' : 'coveo-descending');\n      }\n    }\n  }\n\n  private updateAccessibilityProperties() {\n    this.sortButton.setAttribute('aria-controls', this.resultListsIds);\n    const directionIsInitial = this.currentDirection === this.initialDirection;\n    this.sortButton.setAttribute('aria-checked', `${this.isSelected() && directionIsInitial}`);\n    if (this.isToggle()) {\n      this.directionButton.setAttribute('aria-controls', this.resultListsIds);\n      this.directionButton.setAttribute('aria-checked', `${this.isSelected() && !directionIsInitial}`);\n    }\n  }\n\n  private get resultListsIds() {\n    const resultLists = this.searchInterface.getComponents('ResultList') as Component[];\n    return resultLists.map(resultList => resultList.element.id).join(' ');\n  }\n\n  private getDirectionalLabel(direction: VALID_DIRECTION) {\n    const localizedCaption = l(this.displayedSortText);\n    return direction === VALID_DIRECTION.DESCENDING\n      ? l('SortResultsByDescending', localizedCaption)\n      : l('SortResultsByAscending', localizedCaption);\n  }\n\n  private getOmnidirectionalLabel(): string {\n    const localizedCaption = l(this.displayedSortText);\n    return l('SortResultsBy', localizedCaption);\n  }\n\n  private updateQueryStateModel() {\n    this.queryStateModel.set(QueryStateModel.attributesEnum.sort, this.currentCriteria.toString());\n  }\n}\n\nInitialization.registerAutoCreateComponent(Sort);\n\n\n\n// WEBPACK FOOTER //\n// ./src/ui/Sort/Sort.ts","import { chain, contains, first, values } from 'underscore';\nimport { Assert } from '../../misc/Assert';\nimport { QueryBuilder } from '../../ui/Base/QueryBuilder';\n\nexport enum VALID_SORT {\n  RELEVANCY = 'relevancy',\n  DATE = 'date',\n  QRE = 'qre'\n}\n\nexport enum VALID_DIRECTION {\n  ASCENDING = 'ascending',\n  DESCENDING = 'descending'\n}\n\nexport class SortCriterion {\n  private static sortsNeedingDirection = [VALID_SORT.DATE];\n\n  /**\n   * Create a new SortCriteria\n   * @param sort The sort criteria (e.g.: relevancy, date)\n   * @param direction The direction by which to sort (e.g.: ascending, descending)\n   */\n  constructor(public sort: VALID_SORT, public direction: VALID_DIRECTION | '' = '') {\n    if (!SortCriterion.sortIsField(sort)) {\n      Assert.check(\n        this.isValidSort(sort),\n        `${sort} is not a valid sort criteria. Valid values are ${values(VALID_SORT)} or a valid index sortable index field.`\n      );\n    }\n    if (SortCriterion.sortNeedsDirection(sort)) {\n      Assert.check(\n        this.isValidDirection(direction),\n        `${direction} is not a valid sort criteria direction. Valid values are ${values(VALID_DIRECTION)}`\n      );\n    } else {\n      Assert.check(direction == '');\n    }\n  }\n\n  private isValidDirection(direction: string): direction is VALID_DIRECTION {\n    return chain(VALID_DIRECTION)\n      .values()\n      .contains(direction as any)\n      .value();\n  }\n\n  private isValidSort(sort: string): sort is VALID_SORT {\n    return chain(VALID_SORT)\n      .values()\n      .contains(sort as any)\n      .value();\n  }\n\n  private static sortIsField(criteria: string) {\n    return criteria.charAt(0) == '@';\n  }\n\n  private static sortNeedsDirection(sort: string) {\n    return contains(SortCriterion.sortsNeedingDirection, sort) || SortCriterion.sortIsField(sort);\n  }\n}\n\nexport class SortCriteria {\n  private criteria: SortCriterion[] = [];\n\n  constructor(rawCriteriaString: string) {\n    const criteria = rawCriteriaString.split(';');\n    criteria.forEach(criterion => {\n      const split = criterion.match(/\\S+/g);\n      this.criteria.push(new SortCriterion(split[0] as VALID_SORT, split[1] as VALID_DIRECTION));\n    });\n  }\n\n  public get direction() {\n    return first(this.criteria).direction;\n  }\n\n  public get sort() {\n    return first(this.criteria).sort;\n  }\n\n  /**\n   * Return a new SortCriteria from a string\n   * @param criteria The string from which to create the SortCriteria\n   */\n  static parse(criteria: string): SortCriteria {\n    return new SortCriteria(criteria);\n  }\n\n  /**\n   * Put the sort criteria in the passed queryBuilder\n   * @param queryBuilder The queryBuilder in which to put the sort criteria.\n   */\n  public putInQueryBuilder(queryBuilder: QueryBuilder) {\n    Assert.exists(queryBuilder);\n    queryBuilder.sortCriteria = this.toString()\n      .split(';')\n      .join(',');\n  }\n\n  /**\n   * Returns a string representation of the sort criteria (e.g.: 'date ascending').\n   */\n  public toString(): string {\n    return this.criteria\n      .map(criterion => {\n        return criterion.direction ? `${criterion.sort} ${criterion.direction}` : `${criterion.sort}`;\n      })\n      .join(';');\n  }\n\n  /**\n   * Checks if the SortCriteria is equal to another.\n   * @param criteria The SortCriteria to compare with\n   */\n  public equals(criteria: SortCriteria): boolean {\n    return criteria.toString() == this.toString();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/ui/Sort/SortCriteria.ts"],"sourceRoot":""}