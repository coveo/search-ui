{"version":3,"sources":["MissingTerms.min__98539434d87c7c85e52d.js","./src/ui/MissingTerm/MissingTerms.ts"],"names":["webpackJsonpCoveo__temporary","291","module","exports","__webpack_require__","__extends","this","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","value","element","options","bindings","result","MissingTerms","ID","ComponentOptions","initComponentOptions","addMissingTerms","_this","get","terms","absentTerms","term","regex","createWordBoundaryDelimitedRegex","query","queryStateModel","exec","originalKeywordInQuery","push","enumerable","configurable","addTermForcedToAppear","missingTerms","indexOf","logger","warn","toString","updateTermForcedToAppear","termForcedToAppear","set","length","missingTermElement","buildContainer","hideMissingTermsOverTheNumberOfResults","map","$$","append","elements","buildCaption","el","buildMissingTerms","forEach","className","caption","filter","isValidTerm","makeTermClickableIfEnabled","executeNewQuery","missingTerm","queryController","executeQuery","clickable","termElement","on","logAnalyticsAddMissingTerm","XRegExp","MissingTermManager","wordBoundary","containsFeaturedResults","allMissingTerms","tagName","numberOfTerms","index","hide","nbMoreResults","showMore","l","showAllHiddenMissingTerms","find","parentNode","removeChild","findAll","show","removeAttribute","isNonBoundaryTerm","match","every","word","usageAnalytics","logSearchEvent","analyticsActionCauseList","addMissingTerm","buildBooleanOption","defaultValue","buildLocalizedStringOption","localizedString","buildNumberOption","min","doExport","exportGlobally","Component","Initialization","registerAutoCreateComponent","694"],"mappings":"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","file":"MissingTerms.min__98539434d87c7c85e52d.js","sourcesContent":["webpackJsonpCoveo__temporary([68],{\n\n/***/ 291:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(694);\nvar Core_1 = __webpack_require__(20);\nvar GlobalExports_1 = __webpack_require__(3);\nvar AnalyticsActionListMeta_1 = __webpack_require__(10);\nvar Component_1 = __webpack_require__(7);\nvar ComponentOptions_1 = __webpack_require__(8);\nvar MissingTermManager_1 = __webpack_require__(203);\nvar XRegExp = __webpack_require__(204);\n/**\n * This [result template component](https://docs.coveo.com/en/513/#using-result-template-components) renders a list of query terms\n * that were not matched by the associated result item.\n *\n * @availablesince [July 2019 Release (v2.6459)](https://docs.coveo.com/en/2938/)\n */\nvar MissingTerms = /** @class */ (function (_super) {\n    __extends(MissingTerms, _super);\n    /**\n     * Creates a new `MissingTerms` component instance.\n     * @param element The element on which to instantiate the component.\n     * @param options The configuration options for the component.\n     * @param bindings The bindings required by the component to function normally. If not set, these will be automatically resolved (with a slower execution time).\n     * @param result The query result item to associate the component with.\n     */\n    function MissingTerms(element, options, bindings, result) {\n        var _this = _super.call(this, element, MissingTerms.ID, bindings) || this;\n        _this.element = element;\n        _this.options = options;\n        _this.result = result;\n        _this.options = ComponentOptions_1.ComponentOptions.initComponentOptions(element, MissingTerms, options);\n        _this.addMissingTerms();\n        return _this;\n    }\n    Object.defineProperty(MissingTerms.prototype, \"missingTerms\", {\n        /**\n         *Returns all original basic query expression terms that were not matched by the result item the component instance is associated with.\n         */\n        get: function () {\n            var terms = [];\n            for (var _i = 0, _a = this.result.absentTerms; _i < _a.length; _i++) {\n                var term = _a[_i];\n                var regex = this.createWordBoundaryDelimitedRegex(term);\n                var query = this.queryStateModel.get('q');\n                var result = regex.exec(query);\n                if (result) {\n                    var originalKeywordInQuery = result[4];\n                    terms.push(originalKeywordInQuery);\n                }\n            }\n            return terms;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Injects a term in the advanced part of the query expression (aq) to filter out items that do not match the term.\n     * @param term The term to add to the advanced query expression.\n     */\n    MissingTerms.prototype.addTermForcedToAppear = function (term) {\n        if (this.missingTerms.indexOf(term) === -1) {\n            this.logger.warn(\"Method execution aborted because the term to inject in aq (\\\"\" + term + \"\\\") is not a missing term.\", \"Allowed missing terms: \" + this.missingTerms.toString() + \".\");\n            return;\n        }\n        this.updateTermForcedToAppear();\n        this.termForcedToAppear.push(term);\n        this.queryStateModel.set('missingTerms', this.termForcedToAppear.slice());\n    };\n    MissingTerms.prototype.updateTermForcedToAppear = function () {\n        this.termForcedToAppear = this.queryStateModel.get('missingTerms').slice();\n    };\n    MissingTerms.prototype.addMissingTerms = function () {\n        var _this = this;\n        if (this.missingTerms.length === 0) {\n            return;\n        }\n        var missingTermElement = this.buildContainer();\n        if (missingTermElement.length > 1) {\n            this.hideMissingTermsOverTheNumberOfResults(missingTermElement);\n            missingTermElement.map(function (element) {\n                Core_1.$$(_this.element).append(element);\n            });\n        }\n    };\n    MissingTerms.prototype.buildContainer = function () {\n        var elements = [];\n        elements.push(this.buildCaption().el);\n        this.buildMissingTerms().forEach(function (term) {\n            if (term) {\n                elements.push(term.el);\n            }\n        });\n        return elements;\n    };\n    MissingTerms.prototype.buildCaption = function () {\n        return Core_1.$$('span', { className: 'coveo-field-caption' }, this.options.caption);\n    };\n    MissingTerms.prototype.buildMissingTerms = function () {\n        var _this = this;\n        var validTerms = this.missingTerms.filter(function (term) { return _this.isValidTerm(term); });\n        var terms = validTerms.map(function (term) {\n            return _this.makeTermClickableIfEnabled(term);\n        });\n        return terms;\n    };\n    MissingTerms.prototype.executeNewQuery = function (missingTerm) {\n        if (missingTerm === void 0) { missingTerm = this.queryStateModel.get('q'); }\n        this.queryController.executeQuery();\n    };\n    MissingTerms.prototype.makeTermClickableIfEnabled = function (term) {\n        var _this = this;\n        if (this.options.clickable) {\n            var termElement = Core_1.$$('button', { className: 'coveo-missing-term coveo-clickable' }, term);\n            termElement.on('click', function () {\n                _this.addTermForcedToAppear(term);\n                _this.logAnalyticsAddMissingTerm(term);\n                _this.executeNewQuery(term);\n            });\n            return termElement;\n        }\n        else {\n            return Core_1.$$('span', { className: 'coveo-missing-term' }, term);\n        }\n    };\n    MissingTerms.prototype.createWordBoundaryDelimitedRegex = function (term) {\n        return XRegExp(MissingTermManager_1.MissingTermManager.wordBoundary + \"(\" + term + \")\" + MissingTermManager_1.MissingTermManager.wordBoundary, 'gi');\n    };\n    MissingTerms.prototype.containsFeaturedResults = function (term) {\n        this.updateTermForcedToAppear();\n        return this.termForcedToAppear.indexOf(term) !== -1;\n    };\n    MissingTerms.prototype.hideMissingTermsOverTheNumberOfResults = function (elements) {\n        var _this = this;\n        var allMissingTerms = elements.filter(function (element) {\n            return element.tagName === 'BUTTON';\n        });\n        if (allMissingTerms.length <= this.options.numberOfTerms) {\n            return;\n        }\n        for (var index = this.options.numberOfTerms; index < allMissingTerms.length; index++) {\n            Core_1.$$(allMissingTerms[index]).hide();\n        }\n        var nbMoreResults = allMissingTerms.length - this.options.numberOfTerms;\n        var showMore = Core_1.$$('button', { className: 'coveo-missing-term-show-more coveo-clickable' }, Core_1.l('NMore', [nbMoreResults]));\n        showMore.on('click', function () {\n            _this.showAllHiddenMissingTerms();\n        });\n        elements.push(showMore.el);\n    };\n    MissingTerms.prototype.showAllHiddenMissingTerms = function () {\n        var showMore = Core_1.$$(this.element).find('.coveo-missing-term-show-more');\n        showMore.parentNode.removeChild(showMore);\n        var allMissingTerms = Core_1.$$(this.element).findAll('.coveo-missing-term');\n        for (var index = this.options.numberOfTerms; index < allMissingTerms.length; index++) {\n            Core_1.$$(allMissingTerms[index]).show();\n            allMissingTerms[index].removeAttribute('style');\n        }\n    };\n    MissingTerms.prototype.isValidTerm = function (term) {\n        return this.isNonBoundaryTerm(term) && !this.containsFeaturedResults(term);\n    };\n    MissingTerms.prototype.isNonBoundaryTerm = function (term) {\n        //p{L} is a Unicode script that matches any character in any language.\n        var wordWithBreakpoints = \"\\\\p{L}*[-'?*\\u2019.~=,/\\\\\\\\:`;_!&()]+\\\\p{L}*\";\n        var regex = XRegExp(wordWithBreakpoints, 'gi');\n        var query = this.queryStateModel.get('q');\n        var matches = query.match(regex) || [];\n        return matches.every(function (word) {\n            return word.indexOf(term) === -1;\n        });\n    };\n    MissingTerms.prototype.logAnalyticsAddMissingTerm = function (term) {\n        this.usageAnalytics.logSearchEvent(AnalyticsActionListMeta_1.analyticsActionCauseList.addMissingTerm, {\n            missingTerm: term\n        });\n    };\n    MissingTerms.ID = 'MissingTerms';\n    /**\n     * @componentOptions\n     */\n    MissingTerms.options = {\n        /**\n         * Whether to allow the end-user to click a missing term to filter out items that do not match this term.\n         *\n         * **Default:** `true`\n         */\n        clickable: ComponentOptions_1.ComponentOptions.buildBooleanOption({ defaultValue: true }),\n        /**\n         * The text to display before missing terms.\n         *\n         * **Default:** The localized string for `Missing`.\n         */\n        caption: ComponentOptions_1.ComponentOptions.buildLocalizedStringOption({\n            localizedString: function () { return Core_1.l('Missing'); }\n        }),\n        /**\n         * The maximum number of missing term to be displayed\n         *\n         * **Default:** `5`\u001d\u001c\n         * **Minimum value:** `1`\u001d\u001c\n         */\n        numberOfTerms: ComponentOptions_1.ComponentOptions.buildNumberOption({\n            defaultValue: 5,\n            min: 1\n        })\n    };\n    MissingTerms.doExport = function () {\n        GlobalExports_1.exportGlobally({\n            MissingTerms: MissingTerms\n        });\n    };\n    return MissingTerms;\n}(Component_1.Component));\nexports.MissingTerms = MissingTerms;\nCore_1.Initialization.registerAutoCreateComponent(MissingTerms);\n\n\n/***/ }),\n\n/***/ 694:\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// MissingTerms.min__98539434d87c7c85e52d.js","import 'styling/_MissingTerms';\nimport { $$, Initialization, l } from '../../Core';\nimport { exportGlobally } from '../../GlobalExports';\nimport { IQueryResult } from '../../rest/QueryResult';\nimport { Dom } from '../../utils/Dom';\nimport { analyticsActionCauseList, IAnalyticsMissingTerm } from '../Analytics/AnalyticsActionListMeta';\nimport { Component } from '../Base/Component';\nimport { IComponentBindings } from '../Base/ComponentBindings';\nimport { ComponentOptions } from '../Base/ComponentOptions';\nimport { MissingTermManager } from './MissingTermManager';\nimport XRegExp = require('xregexp');\n\nexport interface IMissingTermsOptions {\n  caption?: string;\n  clickable?: boolean;\n  numberOfTerms?: number;\n}\n\n/**\n * This [result template component](https://docs.coveo.com/en/513/#using-result-template-components) renders a list of query terms\n * that were not matched by the associated result item.\n *\n * @availablesince [July 2019 Release (v2.6459)](https://docs.coveo.com/en/2938/)\n */\nexport class MissingTerms extends Component {\n  static ID = 'MissingTerms';\n\n  /**\n   * @componentOptions\n   */\n  static options: IMissingTermsOptions = {\n    /**\n     * Whether to allow the end-user to click a missing term to filter out items that do not match this term.\n     *\n     * **Default:** `true`\n     */\n    clickable: ComponentOptions.buildBooleanOption({ defaultValue: true }),\n    /**\n     * The text to display before missing terms.\n     *\n     * **Default:** The localized string for `Missing`.\n     */\n    caption: ComponentOptions.buildLocalizedStringOption({\n      localizedString: () => l('Missing')\n    }),\n    /**\n     * The maximum number of missing term to be displayed\n     *\n     * **Default:** `5`\u001d\u001c\n     * **Minimum value:** `1`\u001d\u001c\n     */\n    numberOfTerms: ComponentOptions.buildNumberOption({\n      defaultValue: 5,\n      min: 1\n    })\n  };\n\n  static doExport = () => {\n    exportGlobally({\n      MissingTerms: MissingTerms\n    });\n  };\n\n  private termForcedToAppear: string[];\n\n  /**\n   * Creates a new `MissingTerms` component instance.\n   * @param element The element on which to instantiate the component.\n   * @param options The configuration options for the component.\n   * @param bindings The bindings required by the component to function normally. If not set, these will be automatically resolved (with a slower execution time).\n   * @param result The query result item to associate the component with.\n   */\n  constructor(\n    public element: HTMLElement,\n    public options?: IMissingTermsOptions,\n    bindings?: IComponentBindings,\n    public result?: IQueryResult\n  ) {\n    super(element, MissingTerms.ID, bindings);\n\n    this.options = ComponentOptions.initComponentOptions(element, MissingTerms, options);\n    this.addMissingTerms();\n  }\n  /**\n   *Returns all original basic query expression terms that were not matched by the result item the component instance is associated with.\n   */\n  public get missingTerms(): string[] {\n    const terms = [];\n\n    for (const term of this.result.absentTerms) {\n      const regex = this.createWordBoundaryDelimitedRegex(term);\n      const query = this.queryStateModel.get('q');\n      const result = regex.exec(query);\n\n      if (result) {\n        const originalKeywordInQuery = result[4];\n        terms.push(originalKeywordInQuery);\n      }\n    }\n\n    return terms;\n  }\n\n  /**\n   * Injects a term in the advanced part of the query expression (aq) to filter out items that do not match the term.\n   * @param term The term to add to the advanced query expression.\n   */\n  public addTermForcedToAppear(term: string) {\n    if (this.missingTerms.indexOf(term) === -1) {\n      this.logger.warn(\n        `Method execution aborted because the term to inject in aq (\"${term}\") is not a missing term.`,\n        `Allowed missing terms: ${this.missingTerms.toString()}.`\n      );\n      return;\n    }\n    this.updateTermForcedToAppear();\n    this.termForcedToAppear.push(term);\n    this.queryStateModel.set('missingTerms', [...this.termForcedToAppear]);\n  }\n\n  private updateTermForcedToAppear() {\n    this.termForcedToAppear = [...this.queryStateModel.get('missingTerms')];\n  }\n\n  private addMissingTerms() {\n    if (this.missingTerms.length === 0) {\n      return;\n    }\n    const missingTermElement = this.buildContainer();\n    if (missingTermElement.length > 1) {\n      this.hideMissingTermsOverTheNumberOfResults(missingTermElement);\n      missingTermElement.map(element => {\n        $$(this.element).append(element);\n      });\n    }\n  }\n\n  private buildContainer(): HTMLElement[] {\n    const elements: HTMLElement[] = [];\n    elements.push(this.buildCaption().el);\n    this.buildMissingTerms().forEach(term => {\n      if (term) {\n        elements.push(term.el);\n      }\n    });\n    return elements;\n  }\n\n  private buildCaption(): Dom {\n    return $$('span', { className: 'coveo-field-caption' }, this.options.caption);\n  }\n\n  private buildMissingTerms(): Dom[] {\n    const validTerms = this.missingTerms.filter(term => this.isValidTerm(term));\n    const terms: Dom[] = validTerms.map(term => {\n      return this.makeTermClickableIfEnabled(term);\n    });\n    return terms;\n  }\n\n  private executeNewQuery(missingTerm: string = this.queryStateModel.get('q')) {\n    this.queryController.executeQuery();\n  }\n\n  private makeTermClickableIfEnabled(term: string): Dom {\n    if (this.options.clickable) {\n      const termElement = $$('button', { className: 'coveo-missing-term coveo-clickable' }, term);\n      termElement.on('click', () => {\n        this.addTermForcedToAppear(term);\n        this.logAnalyticsAddMissingTerm(term);\n        this.executeNewQuery(term);\n      });\n      return termElement;\n    } else {\n      return $$('span', { className: 'coveo-missing-term' }, term);\n    }\n  }\n\n  private createWordBoundaryDelimitedRegex(term: string): RegExp {\n    return XRegExp(`${MissingTermManager.wordBoundary}(${term})${MissingTermManager.wordBoundary}`, 'gi');\n  }\n\n  private containsFeaturedResults(term: string): boolean {\n    this.updateTermForcedToAppear();\n    return this.termForcedToAppear.indexOf(term) !== -1;\n  }\n\n  private hideMissingTermsOverTheNumberOfResults(elements: HTMLElement[]) {\n    const allMissingTerms = elements.filter(element => {\n      return element.tagName === 'BUTTON';\n    });\n    if (allMissingTerms.length <= this.options.numberOfTerms) {\n      return;\n    }\n    for (let index = this.options.numberOfTerms; index < allMissingTerms.length; index++) {\n      $$(allMissingTerms[index]).hide();\n    }\n    const nbMoreResults = allMissingTerms.length - this.options.numberOfTerms;\n    const showMore = $$('button', { className: 'coveo-missing-term-show-more coveo-clickable' }, l('NMore', [nbMoreResults]));\n\n    showMore.on('click', () => {\n      this.showAllHiddenMissingTerms();\n    });\n    elements.push(showMore.el);\n  }\n\n  private showAllHiddenMissingTerms() {\n    const showMore = $$(this.element).find('.coveo-missing-term-show-more');\n    showMore.parentNode.removeChild(showMore);\n    const allMissingTerms = $$(this.element).findAll('.coveo-missing-term');\n    for (let index = this.options.numberOfTerms; index < allMissingTerms.length; index++) {\n      $$(allMissingTerms[index]).show();\n      allMissingTerms[index].removeAttribute('style');\n    }\n  }\n\n  private isValidTerm(term: string) {\n    return this.isNonBoundaryTerm(term) && !this.containsFeaturedResults(term);\n  }\n\n  private isNonBoundaryTerm(term: string) {\n    //p{L} is a Unicode script that matches any character in any language.\n    const wordWithBreakpoints = `\\\\p{L}*[-'?\\*â€™.~=,\\/\\\\\\\\:\\`;_!&\\(\\)]+\\\\p{L}*`;\n    const regex = XRegExp(wordWithBreakpoints, 'gi');\n    const query = this.queryStateModel.get('q');\n    const matches = query.match(regex) || [];\n    return matches.every((word: string) => {\n      return word.indexOf(term) === -1;\n    });\n  }\n\n  private logAnalyticsAddMissingTerm(term: string) {\n    this.usageAnalytics.logSearchEvent<IAnalyticsMissingTerm>(analyticsActionCauseList.addMissingTerm, {\n      missingTerm: term\n    });\n  }\n}\nInitialization.registerAutoCreateComponent(MissingTerms);\n\n\n\n// WEBPACK FOOTER //\n// ./src/ui/MissingTerm/MissingTerms.ts"],"sourceRoot":""}