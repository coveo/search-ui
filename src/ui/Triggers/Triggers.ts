import {Component} from '../Base/Component';
import {IComponentBindings} from '../Base/ComponentBindings';
import {ComponentOptions} from '../Base/ComponentOptions';
import {Assert} from '../../misc/Assert';
import {QueryEvents, IQuerySuccessEventArgs} from '../../events/QueryEvents';
import {ITriggerNotify, ITriggerExecute, ITriggerRedirect, ITriggerQuery, ITrigger} from '../../rest/Trigger';
import {$$} from '../../utils/Dom';
import {IAnalyticsTriggerNotify, analyticsActionCauseList, IAnalyticsTriggerRedirect, IAnalyticsTriggerQuery, IAnalyticsTriggerExecute} from '../Analytics/AnalyticsActionListMeta';
import {QueryStateModel} from '../../models/QueryStateModel';
import {Initialization} from '../Base/Initialization';

export interface ITriggersOptions {
}

/**
 * This component enables the use of triggers (<code>notify</code>, <code>execute</code>, <code>query</code>, <code>redirect</code>) generated by the Search API
 * based on <a href='https://developers.coveo.com/display/public/SearchREST/Trigger'>Trigger statements</a>
 * in the query pipeline (See <a href='https://developers.coveo.com/display/public/SearchREST/Managing+the+Query+Pipeline'>Managing the Query Pipeline</a>)
 */
export class Triggers extends Component {
  static ID = 'Triggers';
  static options: ITriggersOptions = {};

  /**
   * The list of notifications returned by the Search API for the current query (via 'notify' triggers).<br/>
   * This list is automatically displayed visually in the component.
   */
  public notifications: string[];

  /**
   * Build a new Triggers component
   * @param element
   * @param options
   * @param bindings
   * @param _window
   */
  constructor(public element: HTMLElement, public options?: ITriggersOptions, public bindings?: IComponentBindings, public _window?: Window) {

    super(element, Triggers.ID, bindings);

    this._window = this._window || window;
    this.options = ComponentOptions.initComponentOptions(element, Triggers, options);
    Assert.exists(element);
    Assert.exists(this.options);

    this.notifications = [];

    this.bind.onRootElement(QueryEvents.querySuccess, this.handleProcessNewQueryResults);
  }

  private handleProcessNewQueryResults(data: IQuerySuccessEventArgs) {
    Assert.exists(data);
    Assert.exists(data.results);

    $$(this.element).empty();
    this.notifications.length = 0;
    let showElement = false;

    if (data.results.triggers === undefined) {
      $$(this.element).toggleClass('coveo-visible', showElement);
      return;
    }

    this.executeTriggers(data.results.triggers, 'notify', (trigger: ITriggerNotify) => {

      this.usageAnalytics.logCustomEvent<IAnalyticsTriggerNotify>(analyticsActionCauseList.triggerNotify, {
        notification: trigger.content
      }, this.element);

      this.notifications.push(trigger.content);
      this.element.appendChild($$('div', { className: 'coveo-trigger-notify' }, trigger.content).el);

      showElement = true;
    });

    this.executeTriggers(data.results.triggers, 'redirect', (trigger: ITriggerRedirect) => {

      this.usageAnalytics.logCustomEvent<IAnalyticsTriggerRedirect>(analyticsActionCauseList.triggerRedirect, {
        redirectedTo: trigger.content
      }, this.element);

      this._window.location.replace(trigger.content);
    }, true);

    this.executeTriggers(data.results.triggers, 'query', (trigger: ITriggerQuery) => {
      this.queryStateModel.set(QueryStateModel.attributesEnum.q, trigger.content);
      this.queryController.executeQuery({
        beforeExecuteQuery: () => {
          this.usageAnalytics.logCustomEvent<IAnalyticsTriggerQuery>(analyticsActionCauseList.triggerQuery, {
            query: trigger.content
          }, this.element);
        }
      })
    }, true);

    this.executeTriggers(data.results.triggers, 'execute', (trigger: ITriggerExecute) => {
      try {
        let func: Function = this._window['' + trigger.content.name]
        if (typeof func === 'function') {
          let params = _.object(_.map(trigger.content.params, (value, index) => {
            return ['param' + (index + 1), value]
          }));
          params['element'] = this.element;

          this.usageAnalytics.logCustomEvent<IAnalyticsTriggerExecute>(analyticsActionCauseList.triggerExecute, {
            executed: trigger.content.name
          }, this.element)

          func.apply(this._window, [params]);
        } else {
          this.logger.error(`A trigger tried to call the function '${trigger.content.name}', which doesn't exist.`, this, data.query, trigger);
        }
      } catch (error) {
        this.logger.error(`A trigger called the function '${trigger.content.name}', which threw an error.`, this, data.query, trigger);
      }
    });

    $$(this.element).toggleClass('coveo-visible', showElement);

  }

  private executeTriggers(trigger: ITrigger<any>[], type: string, func: (trigger: ITrigger<any>) => any, single: boolean = false) {
    let triggersOfType = _.filter(trigger, (trigger: ITrigger<any>) => {
      return trigger.type == type
    });
    let oneOrAllTriggers = _.take(triggersOfType, single ? 1 : Number.MAX_VALUE);

    _.each(oneOrAllTriggers, func);
  }
}

Initialization.registerAutoCreateComponent(Triggers);
